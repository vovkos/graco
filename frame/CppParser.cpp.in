%{
--------------------------------------------------------------------------------
--
--  This file is part of the Graco toolkit.
--
--  Graco is distributed under the MIT license.
--  For details see accompanying license.txt file,
--  the public copy of which is also available at:
--  http://tibbo.com/downloads/archive/graco/license.txt
--
--------------------------------------------------------------------------------

dofile(FrameDir .. "/CppParserUtils.lua")
}
$CppFileBegin

#pragma warning(disable: 4065) // warning C4065: switch statement contains 'default' but no 'case' labels

//..............................................................................

// custom symbols

%{
for i = 1, NamedSymbolCount do
	local symbol = SymbolTable[i]
	if symbol.isCustomClass then
		if symbol.valueBlock then
}
struct SymbolNodeValue_$(symbol.name): llk::SymbolNodeValue
{
$(getPpLine(symbol.srcPos.filePath, symbol.valueLine))
$(symbol.valueBlock);
$(getPpLineDefault())
};

struct SymbolNode_$(symbol.name): llk::SymbolNodeImpl<SymbolNodeValue_$(symbol.name)>
%{
		else
}
struct SymbolNode_$(symbol.name): llk::StdSymbolNode
%{
		end -- if
}
{
public:
%{
		if symbol.paramBlock then
}
	struct
	{
$(getPpLine(symbol.srcPos.filePath, symbol.paramLine))
		$((string.gsub(symbol.paramBlock, ",", ";")));
$(getPpLineDefault())
	} m_param;
%{
		end -- if

		if symbol.localBlock then
}
	struct
	{
$(getPpLine(symbol.srcPos.filePath, symbol.localLine))
		$(symbol.localBlock);
$(getPpLineDefault())
	} m_local;
%{
		end -- if
}
	SymbolNode_$(symbol.name)()
	{
		m_index = SymbolKind_$(symbol.name);
%{
		if symbol.enterBlock then
}
		m_flags |= llk::SymbolNodeFlag_HasEnter;
%{
		end -- if

		if symbol.leaveBlock then
}
		m_flags |= llk::SymbolNodeFlag_HasLeave;
%{
		end -- if
}
	}
};

%{
	end -- if
end -- for
}
//..............................................................................

// parser methods

const size_t*
$ParserClassName::getParseTable()
{
	static const size_t parseTable[] =
	{
%{
for i = 1, SymbolCount do
	local row = ParseTable[i]
	emit("\t\t")
	for j = 1, TokenCount do
		emit(row[j], ", ")
	end
	-- emit("\n") also works, but it can cause inconsistent-new-lines warnings on windows
}

%{
end -- for
}
		-1
	};

	return parseTable;
}

const size_t*
$ParserClassName::getSequence(size_t index)
{
	ASSERT(index < SequenceCount);

	static const size_t sequenceTable[] =
	{
%{
for i = 1, SequenceCount do
	local sequence = SequenceTable[i].sequence
	emit(string.format("\t\t/* %2d */  ", i - 1))
	for j = #sequence, 1, -1 do
		emit(sequence[j], ", ")
	end
}-1,
%{
end -- for
}
		-1
	};

	static const size_t sequenceIndexTable[] =
	{
%{
local j = 0;
for i = 1, SequenceCount do
	local sequence = SequenceTable[i].sequence
}
		$j,
%{
	j = j + #sequence + 1 -- to account left side & terminating -1
end -- for
}
		-1
	};

	return sequenceTable + sequenceIndexTable[index];
}

size_t
$ParserClassName::getTokenIndex(int token)
{
	switch (token)
	{
	case 0:
		return EofToken;

%{
for i = 3, TokenCount do
	local token = TokenTable[i]
}
	case $(getTokenString(token)):
		return $(i - 1);

%{
end -- for
}
	default:
		return AnyToken;
	}
}

int
$ParserClassName::getTokenFromIndex(size_t index)
{
	ASSERT(index < TokenCount);

	static const int tokenTable[] =
	{
		0,  // eof
		0,  // any token
%{
for i = 3, TokenCount do
	local token = TokenTable[i]
}
		$(getTokenString(token)),
%{
end -- for
}
		0
	};

	return tokenTable[index];
}

const char*
$ParserClassName::getSymbolName(size_t index)
{
	ASSERT(index < SymbolCount);

	static const char* symbolNameTable[NamedSymbolCount] =
	{
%{
for i = 1, NamedSymbolCount do
	local symbol = SymbolTable[i]
}
		"$(symbol.name)",
%{
end -- for
}
	};

	return
		index < NamedSymbolCount ? symbolNameTable[index] :
		index < NamedSymbolCount + CatchSymbolCount ? "<catch>" :
		"<tmp>";
}

$ParserClassName::SymbolNode*
$ParserClassName::createSymbolNode(size_t index)
{
	ASSERT(index < NamedSymbolCount);

	SymbolNode* node;

	switch (index)
	{
%{
for i = 1, NamedSymbolCount do
	local symbol = SymbolTable[i]
	if symbol.isCustomClass then
}
	case SymbolKind_$(symbol.name):
		node = AXL_MEM_NEW(SymbolNode_$(symbol.name));
		break;

%{
	elseif symbol.enterBlock or symbol.leaveBlock then
}
	case SymbolKind_$(symbol.name):
		node = AXL_MEM_NEW(llk::StdSymbolNode);
		node->m_index = index;
%{
		if symbol.enterBlock then
}
		node->m_flags |= llk::SymbolNodeFlag_HasEnter;
%{
		end -- if

		if symbol.leaveBlock then
}
		node->m_flags |= llk::SymbolNodeFlag_HasLeave;
%{
		end -- if
}
		break;

%{
	end -- if
end -- for
}
	default:
		node = AXL_MEM_NEW(llk::StdSymbolNode);
		node->m_index = index;
	};

	return node;
}

const size_t*
$ParserClassName::getBeacon(size_t index)
{
	ASSERT(index < BeaconCount);

	static const size_t beaconTable[][2] =
	{
%{
for i = 1, BeaconCount do
	local beacon = BeaconTable[i]
}
		{ $(beacon.slot), $(beacon.target) },
%{
end -- for
}
		{ 0 }
	};

	return beaconTable[index];
}

bool
$ParserClassName::action(size_t index)
{
	ASSERT(index < ActionCount);

	switch (index)
	{
%{
for i = 1, ActionCount do
	local action = ActionTable[i]
	local productionSymbol = action.productionSymbol;
}
	case $(i - 1):
		{
		$(getSymbolDeclaration(productionSymbol, SymbolVariableName, "getSymbolTop()"))
$(getPpLine(action.srcPos.filePath, action.srcPos.line))
$(processActionUserCode(action.userCode, action.dispatcher, SymbolVariableName));
$(getPpLineDefault())
		}
		return true;

%{
end  -- for
}
	default:
		ASSERT(false);
		return true;
	}
}

void
$ParserClassName::argument(
	size_t index,
	SymbolNode* symbol
	)
{
	ASSERT(index < ArgumentCount);

	switch (index)
	{
%{
for i = 1, ArgumentCount do
	local argument = ArgumentTable[i]
	local targetSymbol = argument.targetSymbol
	local productionSymbol = argument.productionSymbol
	local valueTable = argument.valueTable
}
	case $(i - 1):
		{
		$(getSymbolDeclaration(targetSymbol, TargetVariableName, "symbol"))
		$(getSymbolDeclaration(productionSymbol, SymbolVariableName, "getSymbolTop()"))
%{
	for j = 1, #valueTable do
		local name = targetSymbol.paramNameTable[j]
		local value = processActionUserCode(valueTable[j], argument.dispatcher, SymbolVariableName)
}
$(getPpLine(argument.srcPos.filePath, argument.srcPos.line))
		$TargetVariableName->m_param.$name = $value;
$(getPpLineDefault())
%{
	end -- for
}
		}
		break;

%{
end -- for
}
	default:
		ASSERT(false);
	}
}

bool
$ParserClassName::enter(size_t index)
{
	ASSERT(index < NamedSymbolCount);

	switch (index)
	{
%{
for i = 1, NamedSymbolCount do
	local symbol = SymbolTable[i]
	if (symbol.enterBlock) then
}
	case SymbolKind_$(symbol.name):
		{
		$(getSymbolDeclaration(symbol, SymbolVariableName, "getSymbolTop()"))
$(getPpLine(symbol.srcPos.filePath, symbol.enterLine))
$(processActionUserCode(symbol.enterBlock, nil, SymbolVariableName));
$(getPpLineDefault())
		}
		return true;

%{
	end -- if
end --for
}
	default:
		ASSERT(false);
		return true;
	}
}

bool
$ParserClassName::leave(size_t index)
{
	ASSERT(index < NamedSymbolCount);

	switch (index)
	{
%{
for i = 1, NamedSymbolCount do
	local symbol = SymbolTable[i]
	if (symbol.leaveBlock) then
}
	case SymbolKind_$(symbol.name):
		{
		$(getSymbolDeclaration(symbol, SymbolVariableName, "getSymbolTop()"))
$(getPpLine(symbol.srcPos.filePath, symbol.leaveLine))
$(processActionUserCode(symbol.leaveBlock, nil, SymbolVariableName));
$(getPpLineDefault())
		}
		return true;

%{
	end -- if
end --for
}
	default:
		ASSERT(false);
		return true;
	}
}

$ParserClassName::LaDfaResult
$ParserClassName::laDfa(
	size_t index,
	int lookaheadToken,
	LaDfaTransition* transition
	)
{
	ASSERT(index < LaDfaCount);

	switch (index)
	{
%{
for i = 1, LaDfaCount do
	local dfaNode = LaDfaTable[i]
}
	case $(i - 1):
%{
	if dfaNode.resolver then
}
		transition->m_productionIndex = $(dfaNode.production);
		transition->m_resolverIndex = $(dfaNode.resolver);
		transition->m_resolverElseIndex = $(dfaNode.resolverElse);
%{
		if dfaNode.hasChainedResolver then
}
		transition->m_flags = llk::LaDfaNodeFlag_HasChainedResolver;
%{
		end -- if
}
		return LaDfaResult_Resolver;

%{
	else
}
		switch (lookaheadToken)
		{
%{
		local transitionTable = dfaNode.transitionTable
		for j = 1, #transitionTable do
			local transition = transitionTable[j]
			local tokenString = getTokenString(transition.token)
}
		case $tokenString:
%{
			if (transition.resolver) then
}
			transition->m_productionIndex = $(transition.production);
			transition->m_resolverIndex = $(transition.resolver);
			transition->m_resolverElseIndex = $(transition.resolverElse);
%{
				if transition.hasChainedResolver then
}
			transition->m_flags = llk::LaDfaNodeFlag_HasChainedResolver;
%{
				end -- if
}
			return LaDfaResult_Resolver;

%{
			else
}
			transition->m_productionIndex = $(transition.production);
			return LaDfaResult_Production;

%{
			end -- if
		end -- for
}
		default:
%{
		if (dfaNode.defaultProduction) then
}
			transition->m_productionIndex = $(dfaNode.defaultProduction);
			return LaDfaResult_Production;
		}

%{
		else
}
			return LaDfaResult_Fail;
		}

%{
		end	-- if
	end -- if
end -- for
}
	default:
		ASSERT(false);
		return LaDfaResult_Fail;
	}
}

bool
$ParserClassName::isSyncToken(
	size_t index,
	int token
	)
{
	switch (index)
	{
%{
for i = NamedSymbolCount + 1, NamedSymbolCount + CatchSymbolCount do
	local symbol = SymbolTable[i]
}
	case $(i - 1):
		switch (token)
		{
%{
	local tokenTable = symbol.syncTokenTable
	for j = 1, #tokenTable do
		local token = tokenTable[j]
}
		case $(getTokenString(token)):
%{
	end -- for
}
			return true;

		default:
			return false;
		}

%{
end -- for
}
	default:
		return false;
	}
}

//..............................................................................

$CppFileEnd
