%{
--------------------------------------------------------------------------------
--
--  This file is part of the Graco toolkit.
--
--  Graco is distributed under the MIT license.
--  For details see accompanying license.txt file,
--  the public copy of which is also available at:
--  http://tibbo.com/downloads/archive/graco/license.txt
--
--------------------------------------------------------------------------------

dofile(FrameDir .. "/CppParserUtils.lua")
}
$HeaderFileBegin

//..............................................................................

enum SymbolKind
{
%{
for i = 1, NamedSymbolCount do
	local symbol = SymbolTable[i]
}
	SymbolKind_$(symbol.name) = $(i - 1),
%{
end -- for
}
};

//..............................................................................

class $ParserClassName: public llk::Parser<$ParserClassName, $TokenClassName>
{
	friend llk::Parser<$ParserClassName, $TokenClassName>;

$Members

protected:
	// custom symbols

%{
for i = 1, NamedSymbolCount do
	local symbol = SymbolTable[i]
	if symbol.isCustomClass then
		if symbol.valueBlock then
}
	struct SymbolNodeValue_$(symbol.name): llk::SymbolNodeValue
	{
$(getPpLine(symbol.srcPos.filePath, symbol.valueLine))
	$(symbol.valueBlock);
$(getPpLineDefault())
	};

	struct SymbolNode_$(symbol.name): llk::SymbolNodeImpl<SymbolNodeValue_$(symbol.name)>
%{
		else
}
	struct SymbolNode_$(symbol.name): llk::StdSymbolNode
%{
		end -- if
}
	{
	public:
%{
		if symbol.paramBlock then
}
		struct
		{
$(getPpLine(symbol.srcPos.filePath, symbol.paramLine))
			$((string.gsub(symbol.paramBlock, ",", ";")));
$(getPpLineDefault())
		} m_param;
%{
		end -- if

		if symbol.localBlock then
}
		struct
		{
$(getPpLine(symbol.srcPos.filePath, symbol.localLine))
			$(symbol.localBlock);
$(getPpLineDefault())
		} m_local;
%{
		end -- if
}
		SymbolNode_$(symbol.name)()
		{
			m_index = SymbolKind_$(symbol.name);
%{
		if symbol.enterBlock then
}
			m_flags |= llk::SymbolNodeFlag_HasEnter;
%{
		end -- if

		if symbol.leaveBlock then
}
			m_flags |= llk::SymbolNodeFlag_HasLeave;
%{
		end -- if
}
		}
	};

%{
	end -- if
end -- for
}
	union MaxNodeSizeCalc
	{
		char m_laDfaNode[sizeof(LaDfaNode)];
		char m_tokenNode[sizeof(TokenNode)];
		char m_stdSymbolNode[sizeof(StdSymbolNode)];
%{
for i = 1, NamedSymbolCount do
	local symbol = SymbolTable[i]
	if symbol.isCustomClass then
}
		char m_symbolNode_$(symbol.name)[sizeof(SymbolNode_$(symbol.name))];
%{
	end -- if
end -- for
}
	};

public:
	enum
	{
		StartSymbol        = $StartSymbol,
		PragmaStartSymbol  = $PragmaStartSymbol,
		EofToken           = 0,
		AnyToken           = 1,

		TokenCount         = $TokenCount,
		NamedSymbolCount   = $NamedSymbolCount,
		CatchSymbolCount   = $CatchSymbolCount,
		SymbolCount        = $SymbolCount,
		SequenceCount      = $SequenceCount,
		ActionCount        = $ActionCount,
		ArgumentCount      = $ArgumentCount,
		BeaconCount        = $BeaconCount,
		LaDfaCount         = $LaDfaCount,
		TotalCount         = $TotalCount,

		TokenFirst         = 0,
		TokenEnd           = $TokenEnd,
		SymbolFirst        = $TokenEnd,
		SymbolEnd          = $SymbolEnd,
		SequenceFirst      = $SymbolEnd,
		SequenceEnd        = $SequenceEnd,
		ActionFirst        = $SequenceEnd,
		ActionEnd          = $ActionEnd,
		ArgumentFirst      = $ActionEnd,
		ArgumentEnd        = $ArgumentEnd,
		BeaconFirst        = $ArgumentEnd,
		BeaconEnd          = $BeaconEnd,
		LaDfaFirst         = $BeaconEnd,
		LaDfaEnd           = $LaDfaEnd,

		MaxNodeSize        = sizeof(MaxNodeSizeCalc),
	};

protected:
	static
	const size_t*
	getParseTable();

	static
	const size_t*
	getSequence(size_t index);

	static
	size_t
	getTokenIndex(int token);

	static
	int
	getTokenFromIndex(size_t index);

	static
	const char*
	getSymbolName(size_t index);

	static
	SymbolNode*
	createSymbolNode(size_t index);

	static
	const size_t*
	getBeacon(size_t index);

	bool
	action(size_t index);

	void
	argument(
		size_t index,
		SymbolNode* symbol
		);

	bool
	enter(size_t index);

	bool
	leave(size_t index);

	LaDfaResult
	laDfa(
		size_t index,
		int lookaheadToken,
		LaDfaTransition* transition
		);

	const int*
	getSyncTokenSet(size_t index);
};

//..............................................................................

$HeaderFileEnd
